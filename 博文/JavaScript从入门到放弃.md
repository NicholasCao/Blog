> 由原生js引发的血案，收录js一些难点，持续更新中

## 大名鼎鼎的闭包（Closure）

#### 词法作用域
在谈闭包之前，我们先来聊聊词法作用域
首先作用域分文词法作用域（静态作用域）和动态作用域，js使用的是词法作用域，因其在词法解析阶段就已经确定了。
#### 什么是作用域？
作用域就是可以作用的区域，即可以使用的区域。
变量的作用域就是可以使用该变量的一个范围。
BB一大堆，现在上代码
```javascript
var a = 1;
function foo (){
	console.log(a);
	var b = 2;
}
foo();  //1
console.log(b);  //undefined
```
foo在使用a的时候可以访问到全局作用域,而在全局作用域是不能访问到函数foo里面的局部作用域。
简单点来说就是：
> 只有函数可以限定作用域，变量声明会提升，访问先在当前找，没有父级作用域来查。
#### 作用域链
作用域链类似于原型链，但两者毫无关系
作用域是链式的， 在当前作用域如果没有找到对应的变量，会逐层向上级作用域查找，直到全局作用域
#### 闭包
回到正题，先上代码
```javascript
function foo(){
	var n=1;
	function bar(){
	  console.log(n) 
	}
	return bar;
}
var result=foo();
result(); // 1
```
这是一般所认为的闭包,foo函数返回了一个bar函数，然后赋值给了result,result调用自身就会输出foo作用域的n。
那闭包有什么用呢？
一个是前面提到的可以读取函数内部的变量，另一个就是让这些变量的值始终保持在内存中。  ------阮一峰

接下来我们来看点有意思的
``` javascript
for (var i=0;i<5;i++) {
  setTimeout ( ()=>{
    console.log(i)
  },10)
}
```
这里输出和我们所想的 0 1 2 3 4不一样
结果是输出5 5 5 5 5
setTimeout的使用涉及到栈的概念。
JavaScript的单线程决定了代码是在堆栈中顺序执行的，而setTimeout回调会先放到消息队列，for循环每执行一次，就会放一个setTimeout到消息队列排队等候，当同步的代码执行完了，再去调用消息队列的回调方法。（好像有点超纲。。）
那如果我们要输出 0 1 2 3 4 呢
``` javascript
for (var i=0;i<5;i++) {
	(function (j){
		setTimeout ( ()=>{
			console.log(j)
		},10)
	})(i)
}
```
我们利用闭包在循环的过程中把 i 当作变量 j 传入匿名函数中，并且把这个变量关起来，这样在全局作用域中 i 改变也不会改变局部作用域中的 j 了

